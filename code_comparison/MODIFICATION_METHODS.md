# Методы доработки базовых моделей Qwen

## Оглавление

1. [Обзор методов модификации](#обзор-методов-модификации)
2. [Добавление поддержки точечных облаков](#добавление-поддержки-точечных-облаков)
3. [Интеграция с базовыми моделями](#интеграция-с-базовыми-моделями)
4. [Сравнение подходов](#сравнение-подходов)
5. [Рекомендации по модификации](#рекомендации-по-модификации)

---

## Обзор методов модификации

### CAD-Recode: Минималистичный подход

**Стратегия:** Минимальные изменения базовой модели для добавления поддержки PC.

**Изменения:**
1. Добавлен один компонент: `FourierPointEncoder`
2. Модифицирован метод `forward()` для интеграции point embeddings
3. Базовый трансформер используется без изменений

**Преимущества:**
- Простота реализации
- Легкость понимания
- Минимальные изменения в архитектуре

**Недостатки:**
- Ограничен только PC
- Нет поддержки других модальностей

### Cadrille: Расширенный подход

**Стратегия:** Использование всей функциональности базовой модели + добавление PC.

**Изменения:**
1. Добавлены два компонента: `FourierEmbedder` и `FourierPointEncoder`
2. Модифицирован метод `forward()` для интеграции PC с визуальными токенами
3. Используется вся функциональность Qwen2VL (visual encoder, RoPE с визуальными токенами)

**Преимущества:**
- Поддержка множественных модальностей
- Гибкая архитектура
- Использование всех возможностей базовой модели

**Недостатки:**
- Более сложная реализация
- Больше параметров модели
- Больше вычислений

---

## Добавление поддержки точечных облаков

### Fourier Point Encoding

**Обоснование:**
- Точечные облака - это неструктурированные данные (набор координат)
- Нужно преобразовать их в структурированное представление для трансформера
- Fourier features позволяют модели лучше понимать пространственные отношения

**Математическая основа:**

Fourier positional encoding преобразует координаты точек `(x, y, z)` в высокоразмерные embeddings:

```
freqs = [2^0, 2^1, ..., 2^7]  # 8 частот
embed = cat([
    points,                    # Исходные координаты (3 dim)
    sin(points * freqs),       # Синусоидальные компоненты (8*3 = 24 dim)
    cos(points * freqs)        # Косинусоидальные компоненты (8*3 = 24 dim)
])                             # Итого: 3 + 24 + 24 = 51 dim
```

Затем проекция в `hidden_size` через линейный слой:
```
point_embeds = Linear(51, hidden_size)(embed)
```

**Реализация в CAD-Recode:**

```python
class FourierPointEncoder(nn.Module):
    def __init__(self, hidden_size):
        super().__init__()
        frequencies = 2.0 ** torch.arange(8, dtype=torch.float32)
        self.register_buffer('frequencies', frequencies, persistent=False)
        self.projection = nn.Linear(51, hidden_size)
    
    def forward(self, points):
        x = points
        # Прямое вычисление Fourier features
        x = (x.unsqueeze(-1) * self.frequencies).view(*x.shape[:-1], -1)
        x = torch.cat((points, x.sin(), x.cos()), dim=-1)
        x = self.projection(x)
        return x
```

**Реализация в Cadrille:**

```python
class FourierEmbedder(nn.Module):
    def __init__(self, num_freqs=6, logspace=True, include_input=True, include_pi=True):
        # ... инициализация frequencies ...
    
    def forward(self, x):
        embed = (x[..., None].contiguous() * self.frequencies).view(*x.shape[:-1], -1)
        if self.include_input:
            return torch.cat((x, embed.sin(), embed.cos()), dim=-1)
        else:
            return torch.cat((embed.sin(), embed.cos()), dim=-1)

class FourierPointEncoder(nn.Module):
    def __init__(self, hidden_size):
        super().__init__()
        self.fourier_embedder = FourierEmbedder(num_freqs=8, include_pi=False)
        self.projection = nn.Linear(51, hidden_size)
    
    def forward(self, points):
        x = self.fourier_embedder(points[..., :3])
        x = self.projection(x)
        return x
```

**Сравнение:**
- **Идентичность формул:** Обе используют одинаковую формулу
- **Различия в структуре:** Cadrille использует базовый класс, CAD-Recode - прямое вычисление
- **Гибкость:** Cadrille более гибкий (можно изменить параметры через `FourierEmbedder`)

---

## Интеграция с базовыми моделями

### CAD-Recode: Интеграция через attention_mask

**Метод:** Использование специального значения `-1` в `attention_mask` для маркировки позиций PC.

**Процесс:**

1. **Подготовка входных данных:**
   ```python
   input_ids = [pad_token_id] * n_points + [im_start_token]
   attention_mask = [-1] * n_points + [1]
   ```

2. **В forward методе:**
   ```python
   # Создание текстовых embeddings
   inputs_embeds = self.model.embed_tokens(input_ids)
   
   # Кодирование point cloud
   point_embeds = self.point_encoder(point_cloud).to(inputs_embeds.dtype)
   
   # Замена pad токенов на point embeddings
   inputs_embeds[attention_mask == -1] = point_embeds.reshape(-1, point_embeds.shape[2])
   
   # Обновление attention_mask
   attention_mask = attention_mask.clone()
   attention_mask[attention_mask == -1] = 1
   ```

**Особенности:**
- Векторная операция через булевую маску
- Простая и эффективная реализация
- Явное маркирование позиций PC

**Преимущества:**
- Простота реализации
- Эффективная векторная операция
- Легко понять и отладить

**Недостатки:**
- Требует специального значения в `attention_mask`
- Менее гибкий подход

### Cadrille: Интеграция через динамические индексы

**Метод:** Вычисление позиций начала последовательностей динамически через `attention_mask`.

**Процесс:**

1. **Подготовка входных данных в collate():**
   ```python
   # Добавление pad токенов перед текстом
   points_inputs = ''.join(n_points * [processor.tokenizer.pad_token])
   if is_pc[i]:
       texts[i] = points_inputs + texts[i]
   ```

2. **В forward методе:**
   ```python
   # Создание текстовых embeddings
   inputs_embeds = self.model.embed_tokens(input_ids)
   
   # Обработка изображений/видео (если есть)
   if pixel_values is not None:
       # ... обработка изображений ...
   if pixel_values_videos is not None:
       # ... обработка видео ...
   
   # Кодирование point cloud
   point_embeds = self.point_encoder(point_clouds.float()).bfloat16()
   
   # Вычисление позиций начала последовательностей
   start_idxs = attention_mask.shape[1] - attention_mask.sum(axis=1)
   
   # Встраивание через цикл по батчу
   for i, start_idx in enumerate(start_idxs):
       if is_pc[i]:
           inputs_embeds[i, start_idx:start_idx + point_embeds.shape[1], :] = point_embeds[i]
   ```

**Особенности:**
- Динамическое вычисление позиций
- Интеграция с визуальными токенами
- Поэлементная обработка батча

**Преимущества:**
- Гибкость (работает с различными длинами последовательностей)
- Интеграция с другими модальностями
- Не требует специальных значений в `attention_mask`

**Недостатки:**
- Более сложная реализация
- Цикл по батчу (менее эффективно чем векторная операция)
- Больше вычислений

### Обработка на последующих итерациях генерации

**Обе модели:**

Point embeddings встраиваются **только на первом проходе**:

```python
if past_key_values is None or past_key_values.get_seq_length() == 0:
    # Встраивание point embeddings
    ...
```

**Обоснование:**
- Point embeddings представляют входные данные (3D геометрию)
- Они не изменяются в процессе генерации
- Кэширование позволяет избежать повторных вычислений
- На последующих итерациях используются только текстовые токены из кэша

**Оптимизация:**
- Значительное ускорение генерации
- Экономия памяти (не нужно хранить point embeddings для каждого токена)
- Упрощение логики генерации

---

## Сравнение подходов

### Архитектурные решения

| Аспект | CAD-Recode | Cadrille |
|--------|------------|----------|
| Наследование | `PreTrainedModel.__init__()` + создание компонентов вручную | `super().__init__(config)` - наследование всей функциональности |
| Базовый трансформер | Создается вручную (`Qwen2Model`) | Наследуется от Qwen2VL |
| lm_head | Создается вручную | Наследуется от Qwen2VL |
| Visual encoder | Нет | Наследуется от Qwen2VL |
| Point encoder | Добавлен | Добавлен |

### Методы интеграции PC

| Аспект | CAD-Recode | Cadrille |
|--------|------------|----------|
| Маркировка позиций | `attention_mask == -1` | Динамический расчет `start_idxs` |
| Метод встраивания | Векторная операция через маску | Цикл по батчу |
| Подготовка данных | Явное создание pad токенов | Добавление в `collate()` |
| Интеграция с визуальными данными | Нет | Да (после обработки изображений/видео) |

### Обработка последовательностей

| Аспект | CAD-Recode | Cadrille |
|--------|------------|----------|
| RoPE | Стандартная | С учетом визуальных токенов |
| Position IDs | Автоматические | Вычисляются с учетом визуальных токенов |
| Обработка кэша | Стандартная | С учетом визуальных токенов |

---

## Рекомендации по модификации

### Когда использовать подход CAD-Recode

1. **Требования:**
   - Нужна только поддержка точечных облаков
   - Простота важнее функциональности
   - Ограниченные ресурсы

2. **Преимущества:**
   - Простая реализация
   - Легко понять и модифицировать
   - Меньше параметров модели
   - Быстрее инференс

3. **Реализация:**
   - Использовать `attention_mask == -1` для маркировки позиций
   - Векторные операции для эффективности
   - Минимальные изменения базовой модели

### Когда использовать подход Cadrille

1. **Требования:**
   - Нужна поддержка множественных модальностей
   - Гибкость важнее простоты
   - Достаточные ресурсы

2. **Преимущества:**
   - Поддержка множественных модальностей
   - Использование всей функциональности базовой модели
   - Гибкая архитектура

3. **Реализация:**
   - Использовать наследование от мультимодальной модели
   - Динамическое вычисление позиций
   - Интеграция с визуальными токенами

### Общие рекомендации

1. **Fourier Point Encoding:**
   - Использовать `num_freqs=8` для баланса между качеством и размерностью
   - `include_pi=False` для точечных облаков (координаты уже нормализованы)
   - Создавать encoder в `float32` для стабильности, затем конвертировать

2. **Интеграция в последовательность:**
   - Встраивать point embeddings только на первом проходе
   - Использовать кэширование для ускорения генерации
   - Обеспечить правильное обновление `attention_mask`

3. **Оптимизации:**
   - Использовать `bfloat16` для модели
   - Flash Attention 2 для ускорения
   - Оптимизировать batch size в зависимости от доступной памяти

4. **Тестирование:**
   - Проверять правильность встраивания point embeddings
   - Убедиться, что кэширование работает корректно
   - Проверить обработку различных размеров батчей

---

## Выводы

### Ключевые различия в подходах

1. **CAD-Recode:**
   - Минималистичный подход
   - Фокус только на PC
   - Простая и эффективная реализация

2. **Cadrille:**
   - Расширенный подход
   - Поддержка множественных модальностей
   - Использование всей функциональности базовой модели

### Влияние на производительность

**CAD-Recode:**
- Меньше вычислений
- Быстрее инференс
- Меньше использование памяти

**Cadrille:**
- Больше вычислений на первом проходе
- Эффективная генерация благодаря кэшированию
- Больше использование памяти (visual encoder)

### Рекомендации

Выбор подхода зависит от требований:
- **Простота и скорость:** CAD-Recode
- **Функциональность и гибкость:** Cadrille

Оба подхода эффективны для своих целей и демонстрируют различные стратегии модификации базовых моделей.
